from media import MediaInfo, MediaControl
import threading
import bluetooth
import time


class BtRemote(MediaInfo, MediaControl):

    __remote_event = None   # event generated by the the remote (this class)
    __reply_event = None    # event generated by the main thread (received)
    __msg = None            # message exchange object
    __server_socket = None  # bluetooth server socket
    __client_socket = None  # bluetooth client socket
    __termination = None

    def __init__(self, remote_event, reply_event, message):
        super().__init__()
        self.__remote_event = remote_event
        self.__reply_event = reply_event
        self.__msg = message
        self.__server_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
        self.__termination = threading.Event()

    def song_name(self):
        pass

    def song_artist(self):
        pass

    def song_year(self):
        pass

    def song_album(self):
        pass

    # listen for replies (data) from "main" thread
    def __reply_listener(self):
        while not self.__termination.is_set():
            if self.__reply_event.is_set():
                self.__reply_event.clear()
                print("got reply:", self.__msg["reply"][0])
                self.reply(self.__msg["reply"][0])
            else:
                time.sleep(0.2)

    def run(self):
        threading.Thread(target=self.__run).start()
        threading.Thread(target=self.__reply_listener).start()

    def __run(self):
        self.__server_socket.bind(("", bluetooth.PORT_ANY))
        self.__server_socket.listen(1)
        port = self.__server_socket.getsockname()[1]
        uuid = "00001101-0000-1000-8000-00805f9b34fb"           # android app looks for this

        bluetooth.advertise_service(self.__server_socket, "MPRadio",
                                    service_id=uuid,
                                    service_classes=[uuid, bluetooth.SERIAL_PORT_CLASS],
                                    profiles=[bluetooth.SERIAL_PORT_PROFILE],)

        self.__client_socket, address = self.__server_socket.accept()

        while not self.__termination.is_set():
            try:
                cmd = self.__client_socket.recv(1024)
            except bluetooth.btcommon.BluetoothError:       # if a client disconnects, listen for new ones
                self.__client_socket, address = self.__server_socket.accept()
                continue

            if len(cmd) > 0:
                cmd = cmd.decode().strip().lower().split()
                self.__msg["command"] = cmd
                self.__msg["source"] = "bluetooth"
                self.__remote_event.set()

        self.__client_socket.close()
        self.__server_socket.close()

    def reply(self, message):
        self.__client_socket.send(bytes(message+"\0", 'UTF-8'))

    def resume(self):
        pass

    def pause(self):
        pass

    def next(self):
        pass

    def previous(self):
        pass

    def repeat(self):
        pass

    def fast_forward(self):
        pass

    def rewind(self):
        pass

    def stop(self):
        self.__termination.set()
